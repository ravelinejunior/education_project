import 'package:bloc_test/bloc_test.dart';
import 'package:dartz/dartz.dart';
import 'package:education_project/core/errors/failures.dart';
import 'package:education_project/src/auth/data/model/user_model.dart';
import 'package:education_project/src/auth/domain/use_cases/forgot_password_use_case.dart';
import 'package:education_project/src/auth/domain/use_cases/sign_out_use_case.dart';
import 'package:education_project/src/auth/domain/use_cases/signin_use_case.dart';
import 'package:education_project/src/auth/domain/use_cases/signup_use_case.dart';
import 'package:education_project/src/auth/domain/use_cases/update_user_use_case.dart';
import 'package:education_project/src/auth/presentation/bloc/auth_bloc.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';

class MockSignIn extends Mock implements SigninUseCase {}

class MockSignUp extends Mock implements SignupUseCase {}

class MockForgotPassword extends Mock implements ForgotPasswordUseCase {}

class MockSignOut extends Mock implements SignOutUseCase {}

class MockUpdateUser extends Mock implements UpdateUserUseCase {}

void main() {
  late SigninUseCase signinUseCase;
  late SignupUseCase signupUseCase;
  late ForgotPasswordUseCase forgotPasswordUseCase;
  late SignOutUseCase signOutUseCase;
  late UpdateUserUseCase updateUserUseCase;
  late AuthBloc authBloc;

  final tSignUpParams = SignUpParams.empty();
  final tSignInParams = SignInParams.empty();
  final tUpdateUserParams = UpdateUserParams.empty();

  const tServerFailure = ServerFailure(
    message: 'user-not-found',
    statusCode: 505,
  );

  setUp(() {
    signinUseCase = MockSignIn();
    signupUseCase = MockSignUp();
    forgotPasswordUseCase = MockForgotPassword();
    signOutUseCase = MockSignOut();
    updateUserUseCase = MockUpdateUser();
    authBloc = AuthBloc(
      signinUseCase: signinUseCase,
      signupUseCase: signupUseCase,
      forgotPasswordUseCase: forgotPasswordUseCase,
      signOutUseCase: signOutUseCase,
      updateUserUseCase: updateUserUseCase,
    );
  });

  /// Registers fallback values for the test, so that we can use [Mock] objects
  /// with the same constructor arguments in multiple tests.
  ///
  /// This is needed because the [Mock] constructor is generated by
  /// [mocktail], and the generated code is not annotated with
  /// [GenerateImmutable], so the instances are not immutable.
  ///
  /// See https://github.com/felangel/mocktail/issues/37
  setUpAll(() {
    registerFallbackValue(tSignUpParams);
    registerFallbackValue(tSignInParams);
    registerFallbackValue(tUpdateUserParams);
  });

  group('[AuthBloc] Initial state', () {
    test('initial state is AuthInitial', () {
      expect(authBloc.state, const AuthInitialState());
    });
  });

  group('[AuthBloc] SignInEvent', () {
    final tUser = LocalUserModel.empty();

    blocTest<AuthBloc, AuthState>(
      'emits [AuthLoading,AuthSignedInState] when [SignInEvent] is added.',
      build: () {
        when(() => signinUseCase(tSignInParams)).thenAnswer(
          (_) async => Right(tUser),
        );
        return authBloc;
      },
      act: (bloc) => bloc.add(
        SignInEvent(
          email: tSignInParams.email,
          password: tSignInParams.password,
        ),
      ),
      expect: () => [
        const AuthLoadingState(),
        AuthSignedInState(tUser),
      ],
      verify: (_) {
        verify(() => signinUseCase(tSignInParams)).called(1);
        verifyNoMoreInteractions(signinUseCase);
      },
    );

    blocTest<AuthBloc, AuthState>(
      'emits [AuthLoading,AuthErrorState] when [SignInEvent] fails.',
      build: () {
        when(() => signinUseCase(tSignInParams)).thenAnswer(
          (_) async => const Left(tServerFailure),
        );
        return authBloc;
      },
      act: (bloc) => bloc.add(
        SignInEvent(
          email: tSignInParams.email,
          password: tSignInParams.password,
        ),
      ),
      expect: () => [
        const AuthLoadingState(),
        AuthErrorState(tServerFailure.message),
      ],
      verify: (_) {
        verify(() => signinUseCase(tSignInParams)).called(1);
        verifyNoMoreInteractions(signinUseCase);
      },
    );
  });

  group('[AuthBloc] SignUpEvent', () {
    blocTest<AuthBloc, AuthState>(
      'emits [AuthLoading,AuthSignedUpState] when [SignUpEvent] is added.',
      build: () {
        when(() => signupUseCase(tSignUpParams)).thenAnswer(
          (_) async => const Right(null),
        );
        return authBloc;
      },
      act: (bloc) => bloc.add(
        SignUpEvent(
          email: tSignUpParams.email,
          password: tSignUpParams.password,
          fullName: tSignUpParams.fullName,
        ),
      ),
      expect: () => [
        const AuthLoadingState(),
        const AuthSignedUpState(),
      ],
      verify: (_) {
        verify(() => signupUseCase(tSignUpParams)).called(1);
        verifyNoMoreInteractions(signupUseCase);
      },
    );

    blocTest<AuthBloc, AuthState>(
      'emits [AuthLoading,AuthErrorState] when [SignUpEvent] fails.',
      build: () {
        when(() => signupUseCase(tSignUpParams)).thenAnswer(
          (_) async => const Left(tServerFailure),
        );
        return authBloc;
      },
      act: (bloc) => bloc.add(
        SignUpEvent(
          email: tSignUpParams.email,
          password: tSignUpParams.password,
          fullName: tSignUpParams.fullName,
        ),
      ),
      expect: () => [
        const AuthLoadingState(),
        AuthErrorState(tServerFailure.message),
      ],
      verify: (_) {
        verify(() => signupUseCase(tSignUpParams)).called(1);
        verifyNoMoreInteractions(signupUseCase);
      },
    );
  });

  group('[AuthBloc] SignOutEvent', () {
    blocTest<AuthBloc, AuthState>(
      'emits [AuthLoading,AuthSignedOutState] when [SignOutEvent] is added.',
      build: () {
        when(() => signOutUseCase()).thenAnswer(
          (_) async => const Right(null),
        );
        return authBloc;
      },
      act: (bloc) => bloc.add(
        const SignOutEvent(),
      ),
      expect: () => [
        const AuthLoadingState(),
        const AuthSignedOutState(),
      ],
      verify: (_) {
        verify(() => signOutUseCase()).called(1);
        verifyNoMoreInteractions(signOutUseCase);
      },
    );

    blocTest<AuthBloc, AuthState>(
      'emits [AuthLoading,AuthErrorState] when [SignOutEvent] fails.',
      build: () {
        when(() => signOutUseCase()).thenAnswer(
          (_) async => const Left(tServerFailure),
        );
        return authBloc;
      },
      act: (bloc) => bloc.add(
        const SignOutEvent(),
      ),
      expect: () => [
        const AuthLoadingState(),
        AuthErrorState(tServerFailure.message),
      ],
      verify: (_) {
        verify(() => signOutUseCase()).called(1);
        verifyNoMoreInteractions(signOutUseCase);
      },
    );
  });

  group('[AuthBloc] UpdateUserEvent', () {
    blocTest<AuthBloc, AuthState>(
      'emits [AuthLoading,AuthUpdatedUserState] when [UpdateUserEvent] '
      'is added. ',
      build: () {
        when(() => updateUserUseCase(tUpdateUserParams)).thenAnswer(
          (_) async => const Right(null),
        );
        return authBloc;
      },
      act: (bloc) => bloc.add(
        UpdateUserEvent(
          action: tUpdateUserParams.action,
          userData: tUpdateUserParams.userData,
        ),
      ),
      expect: () => [
        const AuthLoadingState(),
        const AuthUserUpdate(),
      ],
      verify: (_) {
        verify(() => updateUserUseCase(tUpdateUserParams)).called(1);
        verifyNoMoreInteractions(updateUserUseCase);
      },
    );

    blocTest<AuthBloc, AuthState>(
      'emits [AuthLoading,AuthErrorState] when [UpdateUserEvent] fails.',
      build: () {
        when(() => updateUserUseCase(tUpdateUserParams)).thenAnswer(
          (_) async => const Left(tServerFailure),
        );
        return authBloc;
      },
      act: (bloc) => bloc.add(
        UpdateUserEvent(
          action: tUpdateUserParams.action,
          userData: tUpdateUserParams.userData,
        ),
      ),
      expect: () => [
        const AuthLoadingState(),
        AuthErrorState(tServerFailure.message),
      ],
      verify: (_) {
        verify(() => updateUserUseCase(tUpdateUserParams)).called(1);
        verifyNoMoreInteractions(updateUserUseCase);
      },
    );
  });

  group('[AuthBloc] ForgotPasswordEvent', () {
    blocTest<AuthBloc, AuthState>(
      'emits [AuthLoading,AuthForgotPasswordState] when [ForgotPasswordEvent] '
      'is added. ',
      build: () {
        when(() => forgotPasswordUseCase(tSignInParams.email)).thenAnswer(
          (_) async => const Right(null),
        );
        return authBloc;
      },
      act: (bloc) => bloc.add(
        ForgotPasswordEvent(
          email: tSignInParams.email,
        ),
      ),
      expect: () => [
        const AuthLoadingState(),
        const AuthForgotPasswordState(),
      ],
      verify: (_) {
        verify(() => forgotPasswordUseCase(tSignInParams.email)).called(1);
        verifyNoMoreInteractions(forgotPasswordUseCase);
      },
    );

    blocTest<AuthBloc, AuthState>(
      'emits [AuthLoading,AuthErrorState] when [ForgotPasswordEvent] fails.',
      build: () {
        when(() => forgotPasswordUseCase(tSignInParams.email)).thenAnswer(
          (_) async => const Left(tServerFailure),
        );
        return authBloc;
      },
      act: (bloc) => bloc.add(
        ForgotPasswordEvent(
          email: tSignInParams.email,
        ),
      ),
      expect: () => [
        const AuthLoadingState(),
        AuthErrorState(tServerFailure.message),
      ],
      verify: (_) {
        verify(() => forgotPasswordUseCase(tSignInParams.email)).called(1);
        verifyNoMoreInteractions(forgotPasswordUseCase);
      },
    );
  });

  tearDown(() => authBloc.close());
}
